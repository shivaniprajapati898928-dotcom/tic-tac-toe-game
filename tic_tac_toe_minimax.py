"""
Tic-Tac-Toe with an AI opponent using Minimax + Alpha-Beta pruning.

How to run:
    python tic_tac_toe_minimax.py

Controls:
 - Board positions are numbered 1..9 as follows:
     1 | 2 | 3
    ---+---+---
     4 | 5 | 6
    ---+---+---
     7 | 8 | 9

 - You can choose to be X or O. X goes first.
 - The AI uses minimax with alpha-beta pruning to choose optimal moves.

Features:
 - Human vs AI, Human vs Human, or AI vs AI modes
 - Clear terminal UI and input validation
 - Well-commented, easy to modify for experiments

Author: Generated by ChatGPT
"""

from copy import deepcopy
import math
import random

EMPTY = ' '
PLAYER_X = 'X'
PLAYER_O = 'O'

WIN_LINES = [
    (0, 1, 2),
    (3, 4, 5),
    (6, 7, 8),
    (0, 3, 6),
    (1, 4, 7),
    (2, 5, 8),
    (0, 4, 8),
    (2, 4, 6),
]


def print_board(board):
    """Prints the 3x3 board to the console."""
    def cell(i):
        return board[i] if board[i] != EMPTY else str(i + 1)

    print(f" {cell(0)} | {cell(1)} | {cell(2)} ")
    print("---+---+---")
    print(f" {cell(3)} | {cell(4)} | {cell(5)} ")
    print("---+---+---")
    print(f" {cell(6)} | {cell(7)} | {cell(8)} ")


def available_moves(board):
    return [i for i, v in enumerate(board) if v == EMPTY]


def is_full(board):
    return all(v != EMPTY for v in board)


def winner(board):
    """Returns PLAYER_X or PLAYER_O if there's a winner, else None."""
    for a, b, c in WIN_LINES:
        if board[a] == board[b] == board[c] and board[a] != EMPTY:
            return board[a]
    return None


def game_over(board):
    return winner(board) is not None or is_full(board)


def evaluate(board, ai_player):
    """Evaluation function: +1 for ai win, -1 for loss, 0 for draw/ongoing."""
    w = winner(board)
    if w == ai_player:
        return 1
    elif w is not None:
        return -1
    else:
        return 0


def minimax(board, depth, maximizing_player, ai_player, alpha=-math.inf, beta=math.inf):
    """Minimax with alpha-beta pruning.

    Returns a tuple: (best_score, best_move_index)
    """
    if game_over(board) or depth == 0:
        return evaluate(board, ai_player), None

    moves = available_moves(board)
    random.shuffle(moves)  # shuffle to avoid deterministic ties

    if maximizing_player:
        max_eval = -math.inf
        best_move = None
        for m in moves:
            board[m] = ai_player
            eval_score, _ = minimax(board, depth - 1, False, ai_player, alpha, beta)
            board[m] = EMPTY
            if eval_score > max_eval:
                max_eval = eval_score
                best_move = m
            alpha = max(alpha, eval_score)
            if beta <= alpha:
                break  # beta cut-off
        return max_eval, best_move
    else:
        min_eval = math.inf
        best_move = None
        opponent = PLAYER_O if ai_player == PLAYER_X else PLAYER_X
        for m in moves:
            board[m] = opponent
            eval_score, _ = minimax(board, depth - 1, True, ai_player, alpha, beta)
            board[m] = EMPTY
            if eval_score < min_eval:
                min_eval = eval_score
                best_move = m
            beta = min(beta, eval_score)
            if beta <= alpha:
                break  # alpha cut-off
        return min_eval, best_move


def get_best_move(board, ai_player):
    """Get the best move for ai_player using full-depth search (since tic-tac-toe is small)."""
    score, move = minimax(board, depth=9, maximizing_player=(ai_player == PLAYER_X), ai_player=ai_player)
    return move


def human_move(board, player):
    while True:
        try:
            choice = input(f"Player {player} - enter move (1-9): ").strip()
            if choice.lower() in ('q', 'quit', 'exit'):
                print("Exiting game.")
                exit(0)
            idx = int(choice) - 1
            if idx < 0 or idx > 8:
                raise ValueError
            if board[idx] != EMPTY:
                print("Cell already taken — choose another.")
                continue
            return idx
        except ValueError:
            print("Invalid input. Enter a number between 1 and 9.")


def play_game(human_first=True, human_is='X', ai_is='O', mode='human_vs_ai'):
    board = [EMPTY] * 9
    current = PLAYER_X

    print("Welcome to Tic-Tac-Toe (Minimax AI)\n")
    print("Board positions:")
    print_board([str(i + 1) for i in range(9)])
    print()

    while True:
        print_board(board)
        print()

        if mode == 'human_vs_human':
            move = human_move(board, current)
        elif mode == 'human_vs_ai':
            if current == human_is:
                move = human_move(board, current)
            else:
                print(f"AI ({ai_is}) is thinking...")
                move = get_best_move(board, ai_is)
        elif mode == 'ai_vs_ai':
            print(f"AI ({current}) is thinking...")
            move = get_best_move(board, current)
        else:
            raise ValueError("Unknown mode")

        board[move] = current

        w = winner(board)
        if w or is_full(board):
            print_board(board)
            if w:
                print(f"\nGame over — winner: {w}")
            else:
                print("\nGame over — it's a draw.")
            break

        current = PLAYER_O if current == PLAYER_X else PLAYER_X


def choose_mode():
    print("Choose mode:\n 1) Human vs AI\n 2) Human vs Human\n 3) AI vs AI")
    while True:
        c = input("Enter 1/2/3: ").strip()
        if c == '1':
            return 'human_vs_ai'
        if c == '2':
            return 'human_vs_human'
        if c == '3':
            return 'ai_vs_ai'
        print("Invalid choice. Try again.")


if __name__ == '__main__':
    mode = choose_mode()

    if mode == 'human_vs_ai':
        while True:
            p = input("Do you want to be X or O? (X goes first): ").strip().upper()
            if p in ('X', 'O'):
                human = p
                ai = PLAYER_O if human == PLAYER_X else PLAYER_X
                break
            print("Choose X or O.")
        human_first = (human == PLAYER_X)
        play_game(human_first=human_first, human_is=human, ai_is=ai, mode=mode)
    elif mode == 'human_vs_human':
        play_game(mode=mode)
    else:
        print("AI vs AI mode — watch two AIs play optimally.")
        play_game(mode=mode)
